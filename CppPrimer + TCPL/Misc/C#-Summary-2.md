C#-Summary-2.md

C# Summary (2)
================================================================================

Ad147  
<ar><r>

Init: 19Jan01

--------------------------------------------------------------------------------

- [12 C# 可空类型（Nullable）](#12-c-%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8Bnullable)
    - [C# 单问号 ? 与 双问号 ??](#c-%E5%8D%95%E9%97%AE%E5%8F%B7--%E4%B8%8E-%E5%8F%8C%E9%97%AE%E5%8F%B7)
    - [C# 可空类型（Nullable）](#c-%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8Bnullable)
    - [Null 合并运算符（ ?? ）](#null-%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6)
- [13 C# 数组（Array）](#13-c-%E6%95%B0%E7%BB%84array)
    - [声明数组](#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84)
    - [初始化数组](#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84)
    - [赋值给数组](#%E8%B5%8B%E5%80%BC%E7%BB%99%E6%95%B0%E7%BB%84)
    - [访问数组元素](#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0)
    - [C# 数组细节](#c-%E6%95%B0%E7%BB%84%E7%BB%86%E8%8A%82)
        - [C# 多维数组](#c-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84)
        - [C# 交错数组](#c-%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84)
        - [C# 参数数组](#c-%E5%8F%82%E6%95%B0%E6%95%B0%E7%BB%84)
        - [C# Array 类](#c-array-%E7%B1%BB)
- [14 C# 字符串（String）](#14-c-%E5%AD%97%E7%AC%A6%E4%B8%B2string)
    - [创建 String 对象](#%E5%88%9B%E5%BB%BA-string-%E5%AF%B9%E8%B1%A1)
    - [String 类的属性](#string-%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7)
    - [String 类的方法](#string-%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95)
- [15 C# 结构体（Struct）](#15-c-%E7%BB%93%E6%9E%84%E4%BD%93struct)
    - [定义结构体](#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93)
    - [C# 结构的特点](#c-%E7%BB%93%E6%9E%84%E7%9A%84%E7%89%B9%E7%82%B9)
    - [类 vs 结构](#%E7%B1%BB-vs-%E7%BB%93%E6%9E%84)
- [16 C# 枚举（Enum）](#16-c-%E6%9E%9A%E4%B8%BEenum)
    - [声明 enum 变量](#%E5%A3%B0%E6%98%8E-enum-%E5%8F%98%E9%87%8F)
- [17 C# 类（Class）](#17-c-%E7%B1%BBclass)
    - [类的定义](#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89)
    - [成员函数和封装](#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%B0%81%E8%A3%85)
    - [C# 中的构造函数](#c-%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0)
    - [C# 中的析构函数](#c-%E4%B8%AD%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0)
    - [C# 类的静态成员](#c-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98)
- [18 C# 继承](#18-c-%E7%BB%A7%E6%89%BF)
    - [基类和派生类](#%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB)
    - [基类的初始化](#%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96)
    - [C# 多重继承](#c-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF)
- [19 C# 多态性](#19-c-%E5%A4%9A%E6%80%81%E6%80%A7)
    - [静态多态性](#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E6%80%A7)
    - [函数重载](#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD)
    - [动态多态性](#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E6%80%A7)
- [20 C# 运算符重载](#20-c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD)
    - [可重载和不可重载运算符](#%E5%8F%AF%E9%87%8D%E8%BD%BD%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6)
- [21 C# 接口（Interface）](#21-c-%E6%8E%A5%E5%8F%A3interface)
    - [定义接口](#%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3)
    - [接口继承](#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF)
- [22 C# 命名空间（Namespace）](#22-c-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4namespace)
    - [using 关键字](#using-%E5%85%B3%E9%94%AE%E5%AD%97)
    - [嵌套命名空间](#%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4)
- [23 C# 预处理器指令](#23-c-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4)
    - [C# 预处理器指令列表](#c-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%97%E8%A1%A8)
    - [#define 预处理器](#define-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8)
    - [条件指令](#%E6%9D%A1%E4%BB%B6%E6%8C%87%E4%BB%A4)
- [24 C# 正则表达式](#24-c-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)
    - [定义正则表达式](#%E5%AE%9A%E4%B9%89%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)
- [25 C# 异常处理](#25-c-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86)
    - [语法](#%E8%AF%AD%E6%B3%95)
    - [C# 中的异常类](#c-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB)
    - [异常处理](#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86)
    - [创建用户自定义异常](#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8)
    - [抛出对象](#%E6%8A%9B%E5%87%BA%E5%AF%B9%E8%B1%A1)
- [26 C# 文件的输入与输出](#26-c-%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA)
    - [C# I/O 类](#c-io-%E7%B1%BB)
    - [FileStream 类](#filestream-%E7%B1%BB)
    - [C# 高级文件操作](#c-%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C)

12 C# 可空类型（Nullable）
--------------------------------------------------------------------------------

### C# 单问号 ? 与 双问号 ??

`?` : 单问号用于对 int,double,bool 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 NullAble 类型的。

```cs
int? i = 3 
// 等同于
Nullable<int> i = new Nullable<int>(3);

int i; //默认值0
int? ii; //默认值null
```

?? : 双问号 可用于判断一个变量在为 null 时返回一个指定的值。

### C# 可空类型（Nullable）

C# 提供了一个特殊的数据类型，nullable 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。

例如，Nullable< Int32 >，读作"可空的 Int32"，可以被赋值为 -2,147,483,648 到 2,147,483,647 之间的任意值，也可以被赋值为 null 值。类似的，Nullable< bool > 变量可以被赋值为 true 或 false 或 null。

在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用。例如，数据库中的布尔型字段可以存储值 true 或 false，或者，该字段也可以未定义。

声明一个 nullable 类型（可空类型）的语法如下：

`<data_type> ? <variable_name> = null;`

### Null 合并运算符（ ?? ）
Null 合并运算符用于定义可空类型和引用类型的默认值。Null 合并运算符为类型转换定义了一个预设值，以防可空类型的值为 Null。Null 合并运算符把操作数类型隐式转换为另一个可空（或不可空）的值类型的操作数的类型。

如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。

```cs
static void Main(string[] args)
{
    double? num1 = null;
    double? num2 = 3.14159;
    double num3;
    num3 = num1 ?? 5.34; // num1 如果为空值则返回 5.34
    num3 = num2 ?? 5.34; // num3 为3.14157
}
```

13 C# 数组（Array）
--------------------------------------------------------------------------------

数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数据的集合，通常认为数组是一个同一类型变量的集合。

所有的数组都是由连续的内存位置组成的。最低的地址对应第一个元素，最高的地址对应最后一个元素。

### 声明数组

在 C# 中声明一个数组，您可以使用下面的语法：  
`datatype[] arrayName;`

其中，

- datatype 用于指定被存储在数组中的元素的类型。
- `[ ]` 指定数组的秩（维度）。秩指定数组的大小。
- arrayName 指定数组的名称。

### 初始化数组

声明一个数组不会在内存中初始化数组。当初始化数组变量时，您可以赋值给数组。

数组是一个引用类型，所以您需要使用 new 关键字来创建数组的实例。  
`double[] balance = new double[10];`

### 赋值给数组

您可以通过使用索引号赋值给一个单独的数组元素，比如：  
`double[] balance = new double[10];`  
`balance[0] = 4500.0;`

您可以在声明数组的同时给数组赋值，比如：  
`double[] balance = { 2340.0, 4523.69, 3421.0 };`

您也可以创建并初始化一个数组，比如：  
`int [] marks = new int[5]  { 99,  98, 92, 97, 95 };`

在上述情况下，你也可以省略数组的大小，比如：  
`int [] marks = new int[]  { 99,  98, 92, 97, 95};`

您也可以赋值一个数组变量到另一个目标数组变量中。在这种情况下，**目标和源会指向相同的内存位置**：  
`int [] marks = new int[]  { 99,  98, 92, 97, 95};`  
`int[] score = marks;`

当您创建一个数组时，C# 编译器会根据数组类型隐式初始化每个数组元素为一个默认值。例如，int 数组的所有元素都会被初始化为 0。

### 访问数组元素

元素是通过带索引的数组名称来访问的。这是通过把元素的索引放置在数组名称后的方括号中来实现的。例如：  
`double salary = balance[9];`

### C# 数组细节

| 概念           | 描述                                                                           |
| -------------- | ------------------------------------------------------------------------------ |
| 多维数组       | C# 支持多维数组。多维数组最简单的形式是二维数组。                              |
| 交错数组       | C# 支持交错数组，即数组的数组。                                                |
| 传递数组给函数 | 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。               |
| 参数数组       | 这通常用于传递未知数量的参数给函数。                                           |
| Array 类       | 在 System 命名空间中定义，是所有数组的基类，并提供了各种用于数组的属性和方法。 |

#### C# 多维数组

C# 支持多维数组。多维数组又称为矩形数组。

您可以声明一个 string 变量的二维数组，如下：  
`string [,] names;`

或者，您可以声明一个 int 变量的三维数组，如下：  
`int [ , , ] m;`

##### 二维数组

多维数组最简单的形式是二维数组。一个二维数组，在本质上，是一个一维数组的列表。

因此，数组中的每个元素是使用形式为 a[ i , j ] 的元素名称来标识的，其中 a 是数组名称，i 和 j 是唯一标识 a 中每个元素的下标。

##### 初始化二维数组

多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。

```cs
int [,] a = new int [3,4] {
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
```

##### 访问二维数组元素

二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。例如：  
`int val = a[2,3];`

#### C# 交错数组

交错数组是数组的数组。您可以声明一个带有 int 值的交错数组 scores，如下所示：  
`int[][] scores = new int[5][];`  
`int[][] scores = new int[2][]{new int[]{92,93,94},new int[]{85,66,87,88}};`

交错数组与二维数组的区别，可以直观的理解为交错数组每一行的长度是可以不一样的。

如果说二维数组像是唐诗，那么交错数组就是宋词，每一句的长短没有限制。

#### C# 参数数组

有时，当声明一个方法时，您不能确定要传递给函数作为参数的参数数目。C# 参数数组解决了这个问题，参数数组通常用于传递未知数量的参数给函数。

##### params 关键字

在使用数组作为形参时，C# 提供了 `params` 关键字，使调用数组为形参的方法时，既可以传递数组实参，也可以传递一组数组元素。params 的使用格式为：  
`public 返回类型 方法名称( params 类型名称[] 数组名称 )`

```cs
public int AddElements(params int[] arr)
{
    int sum = 0;
    foreach (int i in arr)
    {
        sum += i;
    }
    return sum;
}

int sum = app.AddElements(512, 720, 250, 567, 889);
```

#### C# Array 类

Array 类是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种用于数组的属性和方法。

Array 类的属性和方法参阅 MS C# documentation

14 C# 字符串（String）
--------------------------------------------------------------------------------

在 C# 中，您可以使用字符数组来表示字符串，但是，更常见的做法是使用 string 关键字来声明一个字符串变量。string 关键字是 System.String 类的别名。

### 创建 String 对象

您可以使用以下方法之一来创建 string 对象：

- 通过给 String 变量指定一个字符串
- 通过使用 String 类构造函数
- 通过使用字符串串联运算符（ + ）
- 通过检索属性或调用一个返回字符串的方法
- 通过格式化方法来转换一个值或对象为它的字符串表示形式

### String 类的属性

String 类有以下两个属性：
1. Chars: 在当前 String 对象中获取 Char 对象的指定位置。
2. Length: 在当前的 String 对象中获取字符数。

### String 类的方法

访问 MSDN。

15 C# 结构体（Struct）
--------------------------------------------------------------------------------

在 C# 中，结构体是*值类型*数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。struct 关键字用于创建结构体。

### 定义结构体

```cs
struct Books
{
   public string title;
   public string author;
   public string subject;
   public int book_id;
};
```

### C# 结构的特点

您已经用了一个简单的名为 Books 的结构。在 C# 中的结构与传统的 C 或 C++ 中的结构不同。C# 中的结构有以下特点：

- 结构可带有方法、字段、索引、属性、运算符方法和事件。
- 结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义默认的构造函数。默认的构造函数是自动定义的，且不能被改变。
- 与类不同，结构不能继承其他的结构或类。
- 结构不能作为其他结构或类的基础结构。
- 结构可实现一个或多个接口。
- 结构成员不能指定为 abstract、virtual 或 protected。
- 当您使用 new 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 new 操作符即可被实例化。
- 如果不使用 new 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。

### 类 vs 结构

类和结构有以下几个基本的不同点：

- 类是引用类型，结构是值类型。
- 结构不支持继承。
- 结构不能声明默认的构造函数。

16 C# 枚举（Enum）
--------------------------------------------------------------------------------

枚举是一组命名整型常量。枚举类型是使用 enum 关键字声明的。

C# 枚举是值类型。换句话说，枚举包含自己的值，且不能继承或传递继承。

### 声明 enum 变量

声明枚举的一般语法：

```cs
enum <enum_name>
{ 
    enumeration list 
};
```

其中，

- enum_name 指定枚举的类型名称。
- enumeration list 是一个用逗号分隔的标识符列表。

枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下，第一个枚举符号的值是 0. 例如：  
`enum Days { Sun, Mon, tue, Wed, thu, Fri, Sat };`

17 C# 类（Class）
--------------------------------------------------------------------------------

当你定义一个类时，你定义了一个数据类型的蓝图。这实际上并没有定义任何的数据，但它定义了类的名称意味着什么，也就是说，类的对象由什么组成及在这个对象上可执行什么操作。对象是类的实例。构成类的方法和变量成为类的成员。

### 类的定义

```cs
<access specifier> class class_name 
{
    // member variables
    <access specifier> <data type> variable1;
    <access specifier> <data type> variable2;
    ...
    <access specifier> <data type> variableN;

    // member methods
    <access specifier> <return type> method1(parameter_list) 
    {
        // method body 
    }
    <access specifier> <return type> method2(parameter_list) 
    {
        // method body 
    }
    ...
    <access specifier> <return type> methodN(parameter_list) 
    {
        // method body 
    }
}
```

请注意：

- 访问标识符 `<access specifier>` 指定了对类及其成员的访问规则。如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 internal，成员的默认访问标识符是 private。
- 数据类型 `<data type>` 指定了变量的类型，返回类型 `<return type>` 指定了返回的方法返回的数据类型。
- 如果要访问类的成员，你要使用点（.）运算符。
- 点运算符链接了对象的名称和成员的名称。

### 成员函数和封装

类的成员函数是一个在类定义中有它的定义或原型的函数，就像其他变量一样。作为类的一个成员，它能在类的任何对象上操作，且能访问该对象的类的所有成员。

成员变量是对象的属性（从设计角度），且它们保持私有来实现封装。这些变量只能使用公共成员函数来访问。

### C# 中的构造函数

类的 构造函数 是类的一个特殊的成员函数，当创建类的新对象时执行。

构造函数的名称与类的名称完全相同，它没有任何返回类型。

默认的构造函数没有任何参数。但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做参数化构造函数。这种技术可以帮助你在创建对象的同时给对象赋初始值，具体请看下面实例：

### C# 中的析构函数

类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行。

析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。

析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。

### C# 类的静态成员

我们可以使用 static 关键字把类成员定义为静态的。当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。

关键字 static 意味着类中只有一个该成员的实例。静态变量用于定义常量，因为它们的值可以通过直接调用类而不需要创建类的实例来获取。静态变量可在成员函数或类的定义外部进行初始化。你也可以在类的定义内部初始化静态变量。

你也可以把一个成员函数声明为 static。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。下面的实例演示了静态函数的用法：

18 C# 继承
--------------------------------------------------------------------------------

继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。

当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的基类，这个新的类被称为派生类。

继承的思想实现了 属于（IS-A） 关系。例如，哺乳动物 属于（IS-A） 动物，狗 属于（IS-A） 哺乳动物，因此狗 属于（IS-A） 动物。

### 基类和派生类

一个类可以派生自多个类或接口，这意味着它可以从多个基类或接口继承数据和函数。

C# 中创建派生类的语法如下：

```cs
<访问修饰符符> class <基类>
{
 ...
}
class <派生类> : <基类>
{
 ...
}
```

### 基类的初始化

派生类继承了基类的成员变量和成员方法。因此父类对象应在子类对象创建之前被创建。您可以在成员初始化列表中进行父类的初始化。

### C# 多重继承

多重继承指的是一个类别可以同时从多于一个父类继承行为与特征的功能。与单一继承相对，单一继承指一个类别只可以继承自一个父类。

**C# 不支持多重继承**。但是，您可以使用接口来实现多重继承。

19 C# 多态性
--------------------------------------------------------------------------------

多态性意味着有多重形式。在面向对象编程范式中，多态性往往表现为"一个接口，多个功能"。

多态性可以是静态的或动态的。在静态多态性中，函数的响应是在编译时发生的。在动态多态性中，函数的响应是在运行时发生的。

### 静态多态性

在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：

- 函数重载
- 运算符重载

### 函数重载

您可以在同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。不能重载只有返回类型不同的函数声明。

### 动态多态性

C# 允许您使用关键字 abstract 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。抽象类包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。

请注意，下面是有关抽象类的一些规则：

- 您不能创建一个抽象类的实例。
- 您不能在一个抽象类外部声明一个抽象方法。
- 通过在类定义前面放置关键字 sealed，可以将类声明为密封类。当一个类被声明为 sealed 时，它不能被继承。抽象类不能被声明为 sealed。

当有一个定义在类中的函数需要在继承类中实现时，可以使用虚方法。虚方法是使用关键字 virtual 声明的。虚方法可以在不同的继承类中有不同的实现。对虚方法的调用是在运行时发生的。

动态多态性是通过 **抽象类** 和 **虚方法** 实现的。

20 C# 运算符重载
--------------------------------------------------------------------------------

您可以重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 operator 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。

### 可重载和不可重载运算符

###### C# 中运算符重载的能力

| 运算符                                | 描述                                         |
| ------------------------------------- | -------------------------------------------- |
| +, -, !, ~, ++, --                    | 这些一元运算符只有一个操作数，且可以被重载。 |
| +, -, *, /, %                         | 这些二元运算符带有两个操作数，且可以被重载。 |
| ==, !=, <, >, <=, >=                  | 这些比较运算符可以被重载。                   |
| &&,                                   |                                              | 这些条件逻辑运算符不能被直接重载。 |
| +=, -=, *=, /=, %=                    | 这些赋值运算符不能被重载。                   |
| =, ., ?:, ->, new, is, sizeof, typeof | 这些运算符不能被重载。                       |

21 C# 接口（Interface）
--------------------------------------------------------------------------------

接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 "是什么" 部分，派生类定义了语法合同 "怎么做" 部分。

接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。

接口使得实现接口的类或结构在形式上保持一致。

抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。

### 定义接口

接口使用 interface 关键字声明，它与类的声明类似。接口声明默认是 public 的。下面是一个接口声明的实例：

```cs
interface IMyInterface
{
    void MethodToImplement();
}
```

### 接口继承

如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员。

22 C# 命名空间（Namespace）
--------------------------------------------------------------------------------

命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。

定义命名空间
命名空间的定义是以关键字 namespace 开始，后跟命名空间的名称，如下所示：

```cs
namespace namespace_name
{
   // 代码声明
}
```

为了调用支持命名空间版本的函数或变量，会把命名空间的名称置于前面，如下所示：  
`namespace_name.item_name;`

### using 关键字

using 关键字表明程序使用的是给定命名空间中的名称。例如，我们在程序中使用 System 命名空间，其中定义了类 Console。我们可以只写：  
`Console.WriteLine ("Hello there");`

我们可以写完全限定名称，如下：  
`System.Console.WriteLine("Hello there");`

您也可以使用 using 命名空间指令，这样在使用的时候就不用在前面加上命名空间名称。该指令告诉编译器随后的代码使用了指定命名空间中的名称。下面的代码演示了命名空间的应用。

### 嵌套命名空间

命名空间可以被嵌套，即您可以在一个命名空间内定义另一个命名空间。

23 C# 预处理器指令
--------------------------------------------------------------------------------

预处理器指令指导编译器在实际编译开始之前对信息进行预处理。

所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号（;）结束。

C# 编译器没有一个单独的预处理器，但是，指令被处理时就像是有一个单独的预处理器一样。在 C# 中，预处理器指令用于在条件编译中起作用。与 C 和 C++ 不同的是，它们不是用来创建宏。一个预处理器指令必须是该行上的唯一指令。

### C# 预处理器指令列表

| 预处理器指令 | 描述                                                                                    |
| ------------ | --------------------------------------------------------------------------------------- |
| #define      | 它用于定义一系列成为符号的字符。                                                        |
| #undef       | 它用于取消定义符号。                                                                    |
| #if          | 它用于测试符号是否为真。                                                                |
| #else        | 它用于创建复合条件指令，与 #if 一起使用。                                               |
| #elif        | 它用于创建复合条件指令。                                                                |
| #endif       | 指定一个条件指令的结束。                                                                |
| #line        | 它可以让您修改编译器的行数以及（可选地）输出错误和警告的文件名。                        |
| #error       | 它允许从代码的指定位置生成一个错误。                                                    |
| #warning     | 它允许从代码的指定位置生成一级警告。                                                    |
| #region      | 它可以让您在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块。 |
| #endregion   | 它标识着 #region 块的结束。                                                             |

### #define 预处理器
#define 预处理器指令创建符号常量。

#define 允许您定义一个符号，这样，通过使用符号作为传递给 #if 指令的表达式，表达式将返回 true。它的语法如下：  
`#define symbol`

```cs
#define PI 

#if (PI)
    Console.WriteLine("PI is defined");
#else
    Console.WriteLine("PI is not defined");
#endif
```

### 条件指令

您可以使用 #if 指令来创建一个条件指令。条件指令用于测试符号是否为真。如果为真，编译器会执行 #if 和下一个指令之间的代码。  
`#if symbol [operator symbol]...`

常见运算符有：

- == (等于)
- != (不等于)
- && (与)
- || (或)

您也可以用括号把符号和运算符进行分组。条件指令用于在调试版本或编译指定配置时编译代码。一个以 #if 指令开始的条件指令，必须显示地以一个 #endif 指令终止。

24 C# 正则表达式
--------------------------------------------------------------------------------

正则表达式 是一种匹配输入文本的模式。.Net 框架提供了允许这种匹配的正则表达式引擎。模式由一个或多个字符、运算符和结构组成。

### 定义正则表达式

下面列出了用于定义正则表达式的各种类别的字符、运算符和结构。

- 字符转义
- 字符类
- 定位点
- 分组构造
- 限定符
- 反向引用构造
- 备用构造
- 替换
- 杂项构造

25 C# 异常处理
--------------------------------------------------------------------------------

异常是在程序执行期间出现的问题。C# 中的异常是对程序运行时出现的特殊情况的一种响应，比如尝试除以零。

异常提供了一种把程序控制权从某个部分转移到另一个部分的方式。C# 异常处理时建立在四个关键词之上的：`try`、`catch`、`finally` 和 `throw`。

- try：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。
- catch：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。
- finally：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。
- throw：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。

### 语法

假设一个块将出现异常，一个方法使用 try 和 catch 关键字捕获异常。try/catch 块内的代码为受保护的代码，使用 try/catch 语法如下所示：

```cs
try
{
   // 引起异常的语句
}
catch( ExceptionName e1 )
{
   // 错误处理代码
}
catch( ExceptionName e2 )
{
   // 错误处理代码
}
catch( ExceptionName eN )
{
   // 错误处理代码
}
finally
{
   // 要执行的语句
}
```

您可以列出多个 catch 语句捕获不同类型的异常，以防 try 块在不同的情况下生成多个异常。

### C# 中的异常类

C# 异常是使用类来表示的。C# 中的异常类主要是直接或间接地派生于 System.Exception 类。System.ApplicationException 和 System.SystemException 类是派生于 System.Exception 类的异常类。

System.ApplicationException 类支持由应用程序生成的异常。所以程序员定义的异常都应派生自该类。

System.SystemException 类是所有预定义的系统异常的基类。

##### 一些派生自 Sytem.SystemException 类的预定义的异常类

| 异常类                            | 描述                                           |
| --------------------------------- | ---------------------------------------------- |
| System.IO.IOException             | 处理 I/O 错误。                                |
| System.IndexOutOfRangeException   | 处理当方法指向超出范围的数组索引时生成的错误。 |
| System.ArrayTypeMismatchException | 处理当数组类型不匹配时生成的错误。             |
| System.NullReferenceException     | 处理当依从一个空对象时生成的错误。             |
| System.DivideByZeroException      | 处理当除以零时生成的错误。                     |
| System.InvalidCastException       | 处理在类型转换期间生成的错误。                 |
| System.OutOfMemoryException       | 处理空闲内存不足生成的错误。                   |
| System.StackOverflowException     | 处理栈溢出生成的错误。                         |

### 异常处理

C# 以 try 和 catch 块的形式提供了一种结构化的异常处理方案。使用这些块，把核心程序语句与错误处理语句分离开。

这些错误处理块是使用 try、catch 和 finally 关键字实现的。下面是一个当除以零时抛出异常的实例：

```cs
using System;
namespace ErrorHandlingApplication
{
    class DivNumbers
    {
        int result;
        DivNumbers()
        {
            result = 0;
        }
        public void division(int num1, int num2)
        {
            try
            {
                result = num1 / num2;
            }
            catch (DivideByZeroException e)
            {
                Console.WriteLine("Exception caught: {0}", e);
            }
            finally
            {
                Console.WriteLine("Result: {0}", result);
            }

        }
        static void Main(string[] args)
        {
            DivNumbers d = new DivNumbers();
            d.division(25, 0);
            Console.ReadKey();
        }
    }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```shell
Exception caught: System.DivideByZeroException: Attempted to divide by zero. 
at ...
Result: 0
```

### 创建用户自定义异常

您也可以定义自己的异常。用户自定义的异常类是派生自 ApplicationException 类。下面的实例演示了这点：

```cs
using System;
namespace UserDefinedException
{
   class TestTemperature
   {
      static void Main(string[] args)
      {
         Temperature temp = new Temperature();
         try
         {
            temp.showTemp();
         }
         catch(TempIsZeroException e)
         {
            Console.WriteLine("TempIsZeroException: {0}", e.Message);
         }
         Console.ReadKey();
      }
   }
}
public class TempIsZeroException: ApplicationException
{
   public TempIsZeroException(string message): base(message)
   {
   }
}
public class Temperature
{
   int temperature = 0;
   public void showTemp()
   {
      if(temperature == 0)
      {
         throw (new TempIsZeroException("Zero Temperature found"));
      }
      else
      {
         Console.WriteLine("Temperature: {0}", temperature);
      }
   }
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```shell
TempIsZeroException: Zero Temperature found
```

### 抛出对象

如果异常是直接或间接派生自 System.Exception 类，您可以抛出一个对象。您可以在 catch 块中使用 throw 语句来抛出当前的对象，如下所示：

```cs
Catch(Exception e)
{
   ...
   Throw e
}
```

26 C# 文件的输入与输出
--------------------------------------------------------------------------------

一个 文件 是一个存储在磁盘中带有指定名称和目录路径的数据集合。当打开文件进行读写时，它变成一个 **流**。

从根本上说，流是通过通信路径传递的字节序列。有两个主要的流：输入流 和 输出流。输入流用于从文件读取数据（读操作），输出流用于向文件写入数据（写操作）。

### C# I/O 类

System.IO 命名空间有各种不同的类，用于执行各种文件操作，如创建和删除文件、读取或写入文件，关闭文件等。

###### 一些 System.IO 命名空间中常用的非抽象类

| I/O 类         | 描述                               |
| -------------- | ---------------------------------- |
| BinaryReader   | 从二进制流读取原始数据。           |
| BinaryWriter   | 以二进制格式写入原始数据。         |
| BufferedStream | 字节流的临时存储。                 |
| Directory      | 有助于操作目录结构。               |
| DirectoryInfo  | 用于对目录执行操作。               |
| DriveInfo      | 提供驱动器的信息。                 |
| File           | 有助于处理文件。                   |
| FileInfo       | 用于对文件执行操作。               |
| FileStream     | 用于文件中任何位置的读写。         |
| MemoryStream   | 用于随机访问存储在内存中的数据流。 |
| Path           | 对路径信息执行操作。               |
| StreamReader   | 用于从字节流中读取字符。           |
| StreamWriter   | 用于向一个流中写入字符。           |
| StringReader   | 用于读取字符串缓冲区。             |
| StringWriter   | 用于写入字符串缓冲区。             |

### FileStream 类

System.IO 命名空间中的 FileStream 类有助于文件的读写与关闭。该类派生自抽象类 Stream。

您需要创建一个 FileStream 对象来创建一个新的文件，或打开一个已有的文件。创建 FileStream 对象的语法如下：  
`FileStream <object_name> = new FileStream( <file_name>, <FileMode Enumerator>, <FileAccess Enumerator>, <FileShare Enumerator>);`

例如，创建一个 FileStream 对象 F 来读取名为 sample.txt 的文件：  
`FileStream F = new FileStream("sample.txt", FileMode.Open, FileAccess.Read, FileShare.Read);`

### C# 高级文件操作

上面的实例演示了 C# 中简单的文件操作。但是，要充分利用 C# System.IO 类的强大功能，您需要知道这些类常用的属性和方法。

| 主题                   | 描述                                                                                  |
| ---------------------- | ------------------------------------------------------------------------------------- |
| 文本文件的读写         | 它涉及到文本文件的读写。StreamReader 和 StreamWriter 类有助于完成文本文件的读写。     |
| 二进制文件的读写       | 它涉及到二进制文件的读写。BinaryReader 和 BinaryWriter 类有助于完成二进制文件的读写。 |
| Windows 文件系统的操作 | 它让 C# 程序员能够浏览并定位 Windows 文件和目录。                                     |

--------------------------------------------------------------------------------

EOF
