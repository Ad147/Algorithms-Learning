C-Review.md

C Review
================================================================================

Ad  
(from Runoob)  
init: 18Nov06

0 C 程序结构
--------------------------------------------------------------------------------

### 0.0 编译 & 执行 C 程序

 1. 打开一个文本编辑器，添加代码。
 2. 保存文件为 hello.c。
 3. 打开命令提示符，进入到保存文件所在的目录。
 4. 键入 gcc hello.c，输入回车，编译代码。
 5. 如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。
 6. 现在，键入 a.out 来执行程序。
 7. 您可以看到屏幕上显示 "Hello World"。

```shell
$ gcc hello.c
$ ./a.out
Hello, World!
```

请确保您的路径中已包含 gcc 编译器，并确保在包含源文件 hello.c 的目录中运行它。

> gcc 命令如果不指定目标文件名时默认生成的可执行文件名为 `a.out` (linux) 或 `a.exe` (windows)。
>
> 可用 `gcc [源文件名] -o [目标文件名]` 来指定目标文件路径及文件名。
>
> 例如，windows 系统上，`gcc hello.c -o target/hello` 会在 target 目录下生成 hello.exe 文件 (Linux 系统生成 hello 可执行文件)，target 目录必须已存在，`[源文件名]` 和 `-o [目标文件名]` 的顺序可互换， `gcc -o target/hello hello.c` 依然有效。

1 C 基本语法
--------------------------------------------------------------------------------

### 1.1 C 的令牌（Tokens）

C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。
例如，下面的 C 语句包括五个令牌：

`printf("Hello, World! \n");`

这五个令牌分别是：
`printf`
`(`
`"Hello, World! \n"`
`)`
`;`

### 1.2 关键字

下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。

| 关键字     | 说明                                             |
| ---------- | ------------------------------------------------ |
| `auto`     | 声明自动变量                                     |
| `break`    | 跳出当前循环                                     |
| `case`     | 开关语句分支                                     |
| `char`     | 声明字符型变量或函数返回值类型                   |
| `const`    | 声明只读变量                                     |
| `continue` | 结束当前循环，开始下一轮循环                     |
| `default`  | 开关语句中的"其它"分支                           |
| `do`       | 循环语句的循环体                                 |
| `double`   | 声明双精度浮点型变量或函数返回值类型             |
| `else`     | 条件语句否定分支（与 if 连用）                   |
| `enum`     | 声明枚举类型                                     |
| `extern`   | 声明变量或函数是在其它文件或本文件的其他位置定义 |
| `float`    | 声明浮点型变量或函数返回值类型                   |
| `for`      | 一种循环语句                                     |
| `goto`     | 无条件跳转语句                                   |
| `if`       | 条件语句                                         |
| `int`      | 声明整型变量或函数                               |
| `long`     | 声明长整型变量或函数返回值类型                   |
| `register` | 声明寄存器变量                                   |
| `return`   | 子程序返回语句（可以带参数，也可不带参数）       |
| `short`    | 声明短整型变量或函数                             |
| `signed`   | 声明有符号类型变量或函数                         |
| `sizeof`   | 计算数据类型或变量长度（即所占字节数）           |
| `static`   | 声明静态变量                                     |
| `struct`   | 声明结构体类型                                   |
| `switch`   | 用于开关语句                                     |
| `typedef`  | 用以给数据类型取别名                             |
| `unsigned` | 声明无符号类型变量或函数                         |
| `union`    | 声明共用体类型                                   |
| `void`     | 声明函数无返回值或无参数，声明无类型指针         |
| `volatile` | 说明变量在程序执行中可被隐含地改变               |
| `while`    | 循环语句的循环条件                               |

C99 新增关键字
`_Bool` `_Complex` `_Imaginary` `inline` `restrict`

C11 新增关键字
`_Alignas` `_Alignof` `_Atomic` `_Generic` `_Noreturn` `_Static_assert` `_Thread_local`

2 C 数据类型
--------------------------------------------------------------------------------

在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。

C 中的类型可分为以下几种：
 1. 基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。
 2. 枚举类型：它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。
 3. void 类型：类型说明符 void 表明没有可用的值。
 4. 派生类型：它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。  
    数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型。

### 2.1 整数类型

下表列出了关于标准整数类型的存储大小和值范围的细节：

类型	存储大小	值范围
char	1 字节	-128 到 127 或 0 到 255
unsigned char	1 字节	0 到 255
signed char	1 字节	-128 到 127
int	2 或 4 字节	-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647
unsigned int	2 或 4 字节	0 到 65,535 或 0 到 4,294,967,295
short	2 字节	-32,768 到 32,767
unsigned short	2 字节	0 到 65,535
long	4 字节	-2,147,483,648 到 2,147,483,647
unsigned long	4 字节	0 到 4,294,967,295

### 2.2 浮点类型

下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：

类型	存储大小	值范围	精度
float	4 字节	1.2E-38 到 3.4E+38	6 位小数
double	8 字节	2.3E-308 到 1.7E+308	15 位小数
long double	16 字节	3.4E-4932 到 1.1E+4932	19 位小数
头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。

### 2.3 `void` 类型

void 类型指定没有可用的值。它通常用于以下三种情况下：

序号	类型与描述
1	函数返回为空
C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);
2	函数参数为空
C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);
3	指针指向 void
类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。

3 C 变量
--------------------------------------------------------------------------------

4 C 常量
--------------------------------------------------------------------------------

5 C 存储类
--------------------------------------------------------------------------------

存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：
 - auto
 - register
 - static
 - extern

### 5.1 `auto` 存储类

auto 存储类是所有局部变量默认的存储类。

{
   int mount;
   auto int month;
}
上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。

### 5.2 `register` 存储类

register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

{
   register int  miles;
}
寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

### 5.3 `static` 存储类

static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

static 是全局变量的默认存储类，以下两个变量 (count 和 road) 都有一个 static 存储类。

static int Count;
int Road;

main()
{
    printf("%d\n", Count);
    printf("%d\n", Road);
 }

### 5.4 `extern` 存储类

extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。

extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：

第一个文件：main.c

实例
#include <stdio.h>
 
int count ;
extern void write_extern();
 
int main()
{
   count = 5;
   write_extern();
}
第二个文件：support.c

实例
#include <stdio.h>
 
extern int count;
 
void write_extern(void)
{
   printf("count is %d\n", count);
}
在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示：

 $ gcc main.c support.c
这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：

count is 5

C 运算符
--------------------------------------------------------------------------------

C 判断
--------------------------------------------------------------------------------

C 循环
--------------------------------------------------------------------------------

C 函数
--------------------------------------------------------------------------------

C 作用域规则
--------------------------------------------------------------------------------

C 数组
--------------------------------------------------------------------------------

C enum(枚举)
--------------------------------------------------------------------------------

C 指针
--------------------------------------------------------------------------------

C 函数指针与回调函数
--------------------------------------------------------------------------------

### .1 函数指针

```cpp
int max(int x, int y) { return x > y ? x : y; }

int main(void)
{
    /* p 是函数指针 */
    int (* p)(int, int) = & max; // &可以省略
    int a, b, c, d;

    /* 与直接调用函数等价，d = max(max(a, b), c) */
    d = p(p(a, b), c);

    return 0;
}
```

### .2 回调函数

函数指针作为某个函数的参数

函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。
简单讲：回调函数是由别人的函数执行时调用你实现的函数。

> 以下是自知乎作者常溪玲的解说：  
> 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。

实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。
实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。
populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。

```c
#include <stdlib.h>  
#include <stdio.h>

// 回调函数
void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))
{
    for (size_t i=0; i<arraySize; i++)
        array[i] = getNextValue();
}

// 获取随机值
int getNextRandomValue(void) { return rand(); }

int main(void)
{
    int myarray[10];
    populate_array(myarray, 10, getNextRandomValue);

    return 0;
}
```

C 字符串
--------------------------------------------------------------------------------

C 结构体
--------------------------------------------------------------------------------

C 共用体
--------------------------------------------------------------------------------

C 位域
--------------------------------------------------------------------------------

C `typedef`
--------------------------------------------------------------------------------

C 输入 & 输出
--------------------------------------------------------------------------------

C 文件读写
--------------------------------------------------------------------------------

C 预处理器
--------------------------------------------------------------------------------

C 头文件
--------------------------------------------------------------------------------

C 强制类型转换
--------------------------------------------------------------------------------

C 错误处理
--------------------------------------------------------------------------------

C 递归
--------------------------------------------------------------------------------

C 可变参数
--------------------------------------------------------------------------------

C 内存管理
--------------------------------------------------------------------------------

C 语言为内存的分配和管理提供了几个函数。这些函数可以在 <stdlib.h> 头文件中找到。

|     | 函数                                         | 描述                                                                          |
| --- | -------------------------------------------- | ----------------------------------------------------------------------------- |
| 1   | `void *calloc(int num, int size);`           | 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。 |
|     |                                              | 所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。   |
| 2   | `void free(void *address);`                  | 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。                |
| 3   | `void *malloc(int num);`                     | 在堆区分配一块指定大小的内存空间，用来存放数据。                              |
|     |                                              | 这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。                  |
| 4   | `void *realloc(void *address, int newsize);` | 该函数重新分配内存，把内存扩展到 newsize。                                    |

注意：void \* 类型表示未确定类型的指针。C、C++ 规定 void \* 类型可以通过类型转换强制转换为任何其它类型的指针。

C 命令行参数
--------------------------------------------------------------------------------

C 排序算法
--------------------------------------------------------------------------------

C 语言实例
--------------------------------------------------------------------------------

C 经典100例
--------------------------------------------------------------------------------

C 标准库
--------------------------------------------------------------------------------

### C 标准库 - 参考手册

### C 标准库 - <assert.h>

### C 标准库 - <ctype.h>

### C 标准库 - <errno.h>

### C 标准库 - <float.h>

### C 标准库 - <limits.h>

### C 标准库 - <locale.h>

### C 标准库 - <math.h>

### C 标准库 - <setjmp.h>

### C 标准库 - <signal.h>

### C 标准库 - <stdarg.h>

### C 标准库 - <stddef.h>

### C 标准库 - <stdio.h>

### C 标准库 - <stdlib.h>

### C 标准库 - <string.h>

### C 标准库 - <time.h>
